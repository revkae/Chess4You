═══════════════════════════════════════════════════════════════════════════
                    INTEGRATION TEST CALL-GRAPH
                     PairWiseIntegrationTest
═══════════════════════════════════════════════════════════════════════════

                         ┌─────────────────────┐
                         │   JUnit 5 + Mockito │
                         │     (Framework)     │
                         └──────────┬──────────┘
                                    │
                                    │ extends/uses
                                    ▼
          ┌─────────────────────────────────────────────────┐
          │      PairWiseIntegrationTest (621 lines)        │
          │         20 Integration Test Methods             │
          └───┬──────────────────────┬──────────────────┬───┘
              │                      │                  │
      Creates │              Creates │          Tests   │
      Mocks   │              64 Tiles│          Real    │
              ▼                      ▼          Classes ▼
    ┌──────────────────┐   ┌──────────────┐   ┌──────────────┐
    │  MOCK OBJECTS    │   │  MOCK BOARD  │   │ REAL CLASSES │
    └──────────────────┘   └──────────────┘   └──────────────┘


═══════════════════════════════════════════════════════════════════════════
DETAILED CALL-GRAPH STRUCTURE:
═══════════════════════════════════════════════════════════════════════════

1. FRAMEWORK LAYER (JUnit 5 + Mockito)
   │
   ├─── @ExtendWith(MockitoExtension.class)
   ├─── @Test annotations (20 tests)
   ├─── @BeforeEach (setUp() - initializes mocks)
   ├─── @AfterEach (tearDown() - cleanup)
   ├─── @DisplayName (descriptive test names)
   └─── @Order (execution sequence)

2. TEST CLASS: PairWiseIntegrationTest
   │
   ├─── Mock Objects (@Mock annotations):
   │    │
   │    ├── mockWindow           → simulates Window class
   │    ├── mockCamera           → simulates Camera class
   │    ├── mockRenderer         → simulates Renderer class
   │    ├── mockBoardManager     → simulates BoardManager class ⭐
   │    ├── mockPieceManager     → simulates PieceManager class ⭐
   │    ├── mockQuad             → simulates Quad class
   │    └── mockTexture          → simulates Texture class
   │
   ├─── Mock Board:
   │    └── mockBoard: List<Quad> (64 mock tiles)
   │
   └─── 20 Test Methods:
        │
        ├─── TEST 1-5: PAIR 1 (GameManager ↔ BoardManager ↔ PieceManager)
        │    ├── testGameManagerBoardManagerIntegration()
        │    │   └── Verifies: GameManager gets 64-tile board
        │    ├── testPieceManagerBoardManagerTileValidation()
        │    │   └── Verifies: Tile validation (0-63 valid)
        │    ├── testPieceManagerPieceCollection()
        │    │   └── Verifies: Piece collection management
        │    ├── testBoardManagerEdgeDistanceCalculations()
        │    │   └── Verifies: Edge distance calculations
        │    └── testPieceManagerColorFiltering()
        │        └── Verifies: Filter pieces by color
        │
        ├─── TEST 6-10: PAIR 2 (PieceManager ↔ Piece ↔ BoardManager)
        │    ├── testPieceManagerAllyDetection()
        │    │   └── Verifies: hasAlly(), hasEnemy(), isEnemy()
        │    ├── testPieceManagerKingRetrieval()
        │    │   └── Verifies: getKingByColor()
        │    ├── testPieceManagerRookRetrieval()
        │    │   └── Verifies: getRookByColor()
        │    ├── testPieceManagerAddPieceTypes()
        │    │   └── Verifies: addPawn/Knight/Bishop/Queen/King/Rook()
        │    └── testPieceManagerRemovePiece()
        │        └── Verifies: removePiece()
        │
        ├─── TEST 11-14: PAIR 3 (Turn Management ↔ Enums)
        │    ├── testTurnChangeTriggersCheckCalculation()
        │    │   └── Verifies: changeTurn(), check calculations
        │    ├── testPieceColorsEnumOperations()
        │    │   └── Verifies: changeTurn(), getOpposite(), equals()
        │    ├── testPieceDirectionsEnumOperations()
        │    │   └── Verifies: getValue(), isDiagonal()
        │    └── testPieceClassIdentification()
        │        └── Verifies: PieceClass.getValue()
        │
        ├─── TEST 15-16: PAIR 5 (Coordinate System)
        │    ├── testBoardTileToCoordinateConversion()
        │    │   └── Verifies: tile number → row/column
        │    └── testBoardValidateTileBoundaries()
        │        └── Verifies: isValidTileNum()
        │
        ├─── TEST 17-18: PAIR 4 (Rendering Pipeline)
        │    ├── testRendererBoardManagerIntegration()
        │    │   └── Verifies: Renderer draws 64 board tiles
        │    └── testRendererPieceManagerIntegration()
        │        └── Verifies: Renderer draws all pieces
        │
        └─── TEST 19-20: COMPLEX INTEGRATION
             ├── testPieceMoveValidationWithEdgeCalculations()
             │   └── Verifies: Piece uses BoardManager edge data
             └── testCompleteGameFlowIntegration()
                 └── Verifies: Full game initialization flow


═══════════════════════════════════════════════════════════════════════════
MOCK OBJECT BEHAVIORS (when-then-return):
═══════════════════════════════════════════════════════════════════════════

Each mock has 5+ behaviors configured. Example from Test 6:

mockPieceManager:
  when(mockPieceManager.hasAlly(testPiece, 8)).thenReturn(true);     ← Behavior 1
  when(mockPieceManager.hasAlly(testPiece, 16)).thenReturn(false);   ← Behavior 2
  when(mockPieceManager.hasEnemy(testPiece, 48)).thenReturn(true);   ← Behavior 3
  when(mockPieceManager.hasEnemy(testPiece, 56)).thenReturn(false);  ← Behavior 4
  when(mockPieceManager.isEnemy(testPiece, 48)).thenReturn(true);    ← Behavior 5


═══════════════════════════════════════════════════════════════════════════
METHOD CALL FLOW (Example: Test 1)
═══════════════════════════════════════════════════════════════════════════

testGameManagerBoardManagerIntegration()
  │
  ├─ SETUP:
  │  ├─ when(mockBoardManager.getBoard()).thenReturn(mockBoard)
  │  ├─ when(mockBoardManager.getTileCountToEdge(0, NORTH)).thenReturn(7)
  │  ├─ when(mockBoardManager.getTileCountToEdge(0, EAST)).thenReturn(7)
  │  ├─ when(mockBoardManager.getTileCountToEdge(63, SOUTH)).thenReturn(7)
  │  └─ when(mockBoardManager.getTileCountToEdge(63, WEST)).thenReturn(7)
  │
  ├─ EXECUTE:
  │  └─ board = mockBoardManager.getBoard()
  │      └─ Returns: mockBoard (64 tiles)
  │
  └─ VERIFY:
     ├─ assertEquals(64, board.size())  ← Assert board has 64 tiles
     └─ verify(mockBoardManager, times(1)).getBoard()  ← Verify method called


═══════════════════════════════════════════════════════════════════════════
REAL CLASSES BEING TESTED:
═══════════════════════════════════════════════════════════════════════════

PairWiseIntegrationTest
  │
  ├─ Tests → GameManager (real static methods)
  ├─ Tests → BoardManager (real static methods like isValidTileNum)
  ├─ Tests → PieceManager (integration with mocks)
  ├─ Tests → PieceColors enum (real enum operations)
  ├─ Tests → PieceDirections enum (real enum operations)
  ├─ Tests → PieceClass enum (real enum operations)
  └─ Tests → Integration between mocked components


═══════════════════════════════════════════════════════════════════════════
VERIFICATION CALLS (verify()):
═══════════════════════════════════════════════════════════════════════════

After each test executes, we verify interactions:

verify(mockBoardManager).getBoard();                    ← Called once?
verify(mockBoardManager, times(1)).getBoard();          ← Called exactly 1 time?
verify(mockBoardManager, times(64)).texturedDraw(...);  ← Called 64 times?
verify(mockPieceManager, times(2)).hasAlly(...);        ← Called twice?
verify(mockPieceManager).addPawn(WHITE, 8);             ← Called with these args?


═══════════════════════════════════════════════════════════════════════════
TEST EXECUTION FLOW:
═══════════════════════════════════════════════════════════════════════════

./gradlew test --tests PairWiseIntegrationTest
  │
  ├─ JUnit Platform initializes
  │
  ├─ MockitoExtension initializes
  │  └─ Creates all @Mock objects
  │
  ├─ For each @Test method (20 tests):
  │  │
  │  ├─ @BeforeEach: setUp()
  │  │  └─ Create mockBoard with 64 mock Quads
  │  │
  │  ├─ Run test method:
  │  │  ├─ Setup: Configure mock behaviors (when-then-return)
  │  │  ├─ Execute: Run code being tested
  │  │  └─ Verify: Check assertions and mock calls
  │  │
  │  └─ @AfterEach: tearDown()
  │     └─ Clean up (mockBoard.clear())
  │
  └─ Report results:
     └─ Test Results: SUCCESS (20 tests, 20 passed, 0 failed)


═══════════════════════════════════════════════════════════════════════════
KEY STATISTICS:
═══════════════════════════════════════════════════════════════════════════

Test Class:          PairWiseIntegrationTest.java
Lines of Code:       621
Number of Tests:     20
Mock Object Types:   7
Mock Behaviors:      116+ (5-8 per test)
Classes Tested:      8+ (GameManager, BoardManager, PieceManager, etc.)
Integration Pairs:   5 distinct pairs
Success Rate:        100% (20/20 passing)
Execution Time:      ~2 seconds


═══════════════════════════════════════════════════════════════════════════
INTEGRATION PAIRS TESTED:
═══════════════════════════════════════════════════════════════════════════

PAIR 1: GameManager ↔ BoardManager ↔ PieceManager
        └─ Tests: 1, 2, 3, 4, 5, 20

PAIR 2: PieceManager ↔ Piece ↔ BoardManager
        └─ Tests: 6, 7, 8, 9, 10, 19

PAIR 3: PieceManager ↔ PieceColors ↔ PieceDirections
        └─ Tests: 11, 12, 13, 14

PAIR 4: BoardManager ↔ Renderer ↔ PieceManager
        └─ Tests: 17, 18

PAIR 5: BoardManager ↔ Tile System
        └─ Tests: 15, 16


═══════════════════════════════════════════════════════════════════════════
FILE LOCATIONS:
═══════════════════════════════════════════════════════════════════════════

Test Class:
  src/test/java/PairWiseIntegrationTest.java

PlantUML Diagrams:
  diagrams/test-call-graph.puml              ← Test structure diagram
  diagrams/class-diagram.puml                ← Full project diagram
  diagrams/integration-pairs.puml            ← Integration pairs

Text Documentation:
  TEST_CALL_GRAPH.txt                        ← This file
  HOMEWORK3_FINAL_REPORT.md                  ← Complete PDF report


═══════════════════════════════════════════════════════════════════════════
HOW TO VISUALIZE THIS DIAGRAM:
═══════════════════════════════════════════════════════════════════════════

METHOD 1: PlantUML Online
  1. Open: diagrams/test-call-graph.puml
  2. Copy all content
  3. Go to: https://www.planttext.com/
  4. Paste content
  5. Download PNG

METHOD 2: IntelliJ IDEA (Best for Test Structure)
  1. Open: src/test/java/PairWiseIntegrationTest.java
  2. Right-click on class name "PairWiseIntegrationTest"
  3. Select: Diagrams → Show Diagram
  4. This shows test class structure
  5. Export as PNG

METHOD 3: IntelliJ IDEA (For Dependencies)
  1. Open: src/test/java/PairWiseIntegrationTest.java
  2. Right-click anywhere in file
  3. Select: Diagrams → Show Diagram Dependencies
  4. Shows what test depends on
  5. Export as PNG


═══════════════════════════════════════════════════════════════════════════
END OF TEST CALL-GRAPH DOCUMENTATION
═══════════════════════════════════════════════════════════════════════════
